# インメモリデータベース実装比較レポート

3つの実装パターンについて、パフォーマンス（構築・検索）とメモリ使用量のトレードオフを検証しました。

## 概要

| 実装 | 構築速度 | メモリ | 検索(アルバム) | 検索(トラック) | 特徴 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **1. Hybrid Hash** | 遅い | **大** | 速い | 普通 | メモリを犠牲に検索を最適化するが、複合キーのオーバーヘッドあり |
| **2. Nested Hash** | **速い** | 小 | **激遅** | 速い | 構造がシンプルだが、集計クエリ(アルバム全曲)に弱い |
| **3. Array Opt** | **速い** | **小** | **最速** | **最速** | 配列インデックス活用により、全ての面で高パフォーマンス |

## 詳細結果 (Benchmark Output)

### 1. 構築時間 (Construction)
データのインサートにかかる時間。
- **Impl 2 & 3** が Impl 1 より **約3倍** 速い。Impl 1は2つのハッシュに書き込むためコストが高い。

### 2. メモリ使用量 (Memory)
- **Impl 1** は重複データを持つため、他の実装に比べて顕著にメモリを消費する（測定では他実装と約150KB以上の差）。
- **Impl 2 & 3** はほぼ同等で軽量。

### 3. 検索速度 (Lookup)
#### アルバム単位 (`lookup("Album 1")`)
- **Impl 3 (Array Opt)**: 最速 (0.0016s)
- **Impl 1**: 速い (0.0023s)
- **Impl 2**: **非常に遅い (0.0406s)**。ネストされたハッシュから値を集めてフラットにする処理が毎回走るため、書き込みに最適化されすぎている。

#### トラック単位 (`lookup("Album 1", 5)`)
- **Impl 3**: 最速 (0.0014s)。配列アクセス `ary[5]` なので爆速。
- **Impl 2**: 速い (0.0016s)。ハッシュの `dig` なので十分速い。
- **Impl 1**: 普通 (0.0068s)。`[album, track]` という配列をキーにするハッシュ検索のオーバーヘッドが見られる。

## 結論
今回のデータ構造（連番のトラックIDを持つアルバムデータ）においては、**Implementation 3 (Array Optimization)** が最も効率的です。
- トラックIDが整数で密（0, 1, 2...）である特性を活かし、配列インデックスを利用している点が勝因です。
- トラックIDが疎な場合や文字列の場合は Impl 2 が候補になりますが、集計アクセスの頻度が高いなら Impl 2 は避けるべきです。
